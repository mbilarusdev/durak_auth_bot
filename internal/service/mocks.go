// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package service

import (
	"github.com/mbilarusdev/durak_auth_bot/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCodeManager creates a new instance of MockCodeManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCodeManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCodeManager {
	mock := &MockCodeManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCodeManager is an autogenerated mock type for the CodeManager type
type MockCodeManager struct {
	mock.Mock
}

type MockCodeManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCodeManager) EXPECT() *MockCodeManager_Expecter {
	return &MockCodeManager_Expecter{mock: &_m.Mock}
}

// ConsumeIsRightCode provides a mock function for the type MockCodeManager
func (_mock *MockCodeManager) ConsumeIsRightCode(phone string, confirmCode string) (bool, error) {
	ret := _mock.Called(phone, confirmCode)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeIsRightCode")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return returnFunc(phone, confirmCode)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = returnFunc(phone, confirmCode)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(phone, confirmCode)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodeManager_ConsumeIsRightCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumeIsRightCode'
type MockCodeManager_ConsumeIsRightCode_Call struct {
	*mock.Call
}

// ConsumeIsRightCode is a helper method to define mock.On call
//   - phone string
//   - confirmCode string
func (_e *MockCodeManager_Expecter) ConsumeIsRightCode(phone interface{}, confirmCode interface{}) *MockCodeManager_ConsumeIsRightCode_Call {
	return &MockCodeManager_ConsumeIsRightCode_Call{Call: _e.mock.On("ConsumeIsRightCode", phone, confirmCode)}
}

func (_c *MockCodeManager_ConsumeIsRightCode_Call) Run(run func(phone string, confirmCode string)) *MockCodeManager_ConsumeIsRightCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCodeManager_ConsumeIsRightCode_Call) Return(b bool, err error) *MockCodeManager_ConsumeIsRightCode_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockCodeManager_ConsumeIsRightCode_Call) RunAndReturn(run func(phone string, confirmCode string) (bool, error)) *MockCodeManager_ConsumeIsRightCode_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCode provides a mock function for the type MockCodeManager
func (_mock *MockCodeManager) CreateCode(phone string) (string, error) {
	ret := _mock.Called(phone)

	if len(ret) == 0 {
		panic("no return value specified for CreateCode")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(phone)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(phone)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(phone)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodeManager_CreateCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCode'
type MockCodeManager_CreateCode_Call struct {
	*mock.Call
}

// CreateCode is a helper method to define mock.On call
//   - phone string
func (_e *MockCodeManager_Expecter) CreateCode(phone interface{}) *MockCodeManager_CreateCode_Call {
	return &MockCodeManager_CreateCode_Call{Call: _e.mock.On("CreateCode", phone)}
}

func (_c *MockCodeManager_CreateCode_Call) Run(run func(phone string)) *MockCodeManager_CreateCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCodeManager_CreateCode_Call) Return(s string, err error) *MockCodeManager_CreateCode_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockCodeManager_CreateCode_Call) RunAndReturn(run func(phone string) (string, error)) *MockCodeManager_CreateCode_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMessageManager creates a new instance of MockMessageManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMessageManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMessageManager {
	mock := &MockMessageManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMessageManager is an autogenerated mock type for the MessageManager type
type MockMessageManager struct {
	mock.Mock
}

type MockMessageManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMessageManager) EXPECT() *MockMessageManager_Expecter {
	return &MockMessageManager_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type MockMessageManager
func (_mock *MockMessageManager) Send(message string, chatID int) error {
	ret := _mock.Called(message, chatID)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = returnFunc(message, chatID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMessageManager_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockMessageManager_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - message string
//   - chatID int
func (_e *MockMessageManager_Expecter) Send(message interface{}, chatID interface{}) *MockMessageManager_Send_Call {
	return &MockMessageManager_Send_Call{Call: _e.mock.On("Send", message, chatID)}
}

func (_c *MockMessageManager_Send_Call) Run(run func(message string, chatID int)) *MockMessageManager_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMessageManager_Send_Call) Return(err error) *MockMessageManager_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMessageManager_Send_Call) RunAndReturn(run func(message string, chatID int) error) *MockMessageManager_Send_Call {
	_c.Call.Return(run)
	return _c
}

// SendWithContactButton provides a mock function for the type MockMessageManager
func (_mock *MockMessageManager) SendWithContactButton(chatID int) {
	_mock.Called(chatID)
	return
}

// MockMessageManager_SendWithContactButton_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendWithContactButton'
type MockMessageManager_SendWithContactButton_Call struct {
	*mock.Call
}

// SendWithContactButton is a helper method to define mock.On call
//   - chatID int
func (_e *MockMessageManager_Expecter) SendWithContactButton(chatID interface{}) *MockMessageManager_SendWithContactButton_Call {
	return &MockMessageManager_SendWithContactButton_Call{Call: _e.mock.On("SendWithContactButton", chatID)}
}

func (_c *MockMessageManager_SendWithContactButton_Call) Run(run func(chatID int)) *MockMessageManager_SendWithContactButton_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMessageManager_SendWithContactButton_Call) Return() *MockMessageManager_SendWithContactButton_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockMessageManager_SendWithContactButton_Call) RunAndReturn(run func(chatID int)) *MockMessageManager_SendWithContactButton_Call {
	_c.Run(run)
	return _c
}

// NewMockPlayerManager creates a new instance of MockPlayerManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPlayerManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPlayerManager {
	mock := &MockPlayerManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPlayerManager is an autogenerated mock type for the PlayerManager type
type MockPlayerManager struct {
	mock.Mock
}

type MockPlayerManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPlayerManager) EXPECT() *MockPlayerManager_Expecter {
	return &MockPlayerManager_Expecter{mock: &_m.Mock}
}

// CreatePlayer provides a mock function for the type MockPlayerManager
func (_mock *MockPlayerManager) CreatePlayer(phone string, chatID int) (*models.Player, error) {
	ret := _mock.Called(phone, chatID)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlayer")
	}

	var r0 *models.Player
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, int) (*models.Player, error)); ok {
		return returnFunc(phone, chatID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, int) *models.Player); ok {
		r0 = returnFunc(phone, chatID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Player)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, int) error); ok {
		r1 = returnFunc(phone, chatID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlayerManager_CreatePlayer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePlayer'
type MockPlayerManager_CreatePlayer_Call struct {
	*mock.Call
}

// CreatePlayer is a helper method to define mock.On call
//   - phone string
//   - chatID int
func (_e *MockPlayerManager_Expecter) CreatePlayer(phone interface{}, chatID interface{}) *MockPlayerManager_CreatePlayer_Call {
	return &MockPlayerManager_CreatePlayer_Call{Call: _e.mock.On("CreatePlayer", phone, chatID)}
}

func (_c *MockPlayerManager_CreatePlayer_Call) Run(run func(phone string, chatID int)) *MockPlayerManager_CreatePlayer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPlayerManager_CreatePlayer_Call) Return(player *models.Player, err error) *MockPlayerManager_CreatePlayer_Call {
	_c.Call.Return(player, err)
	return _c
}

func (_c *MockPlayerManager_CreatePlayer_Call) RunAndReturn(run func(phone string, chatID int) (*models.Player, error)) *MockPlayerManager_CreatePlayer_Call {
	_c.Call.Return(run)
	return _c
}

// FindByChatID provides a mock function for the type MockPlayerManager
func (_mock *MockPlayerManager) FindByChatID(chatID int) (*models.Player, error) {
	ret := _mock.Called(chatID)

	if len(ret) == 0 {
		panic("no return value specified for FindByChatID")
	}

	var r0 *models.Player
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int) (*models.Player, error)); ok {
		return returnFunc(chatID)
	}
	if returnFunc, ok := ret.Get(0).(func(int) *models.Player); ok {
		r0 = returnFunc(chatID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Player)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int) error); ok {
		r1 = returnFunc(chatID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlayerManager_FindByChatID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByChatID'
type MockPlayerManager_FindByChatID_Call struct {
	*mock.Call
}

// FindByChatID is a helper method to define mock.On call
//   - chatID int
func (_e *MockPlayerManager_Expecter) FindByChatID(chatID interface{}) *MockPlayerManager_FindByChatID_Call {
	return &MockPlayerManager_FindByChatID_Call{Call: _e.mock.On("FindByChatID", chatID)}
}

func (_c *MockPlayerManager_FindByChatID_Call) Run(run func(chatID int)) *MockPlayerManager_FindByChatID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPlayerManager_FindByChatID_Call) Return(player *models.Player, err error) *MockPlayerManager_FindByChatID_Call {
	_c.Call.Return(player, err)
	return _c
}

func (_c *MockPlayerManager_FindByChatID_Call) RunAndReturn(run func(chatID int) (*models.Player, error)) *MockPlayerManager_FindByChatID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByPhone provides a mock function for the type MockPlayerManager
func (_mock *MockPlayerManager) FindByPhone(phone string) (*models.Player, error) {
	ret := _mock.Called(phone)

	if len(ret) == 0 {
		panic("no return value specified for FindByPhone")
	}

	var r0 *models.Player
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*models.Player, error)); ok {
		return returnFunc(phone)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *models.Player); ok {
		r0 = returnFunc(phone)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Player)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(phone)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlayerManager_FindByPhone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByPhone'
type MockPlayerManager_FindByPhone_Call struct {
	*mock.Call
}

// FindByPhone is a helper method to define mock.On call
//   - phone string
func (_e *MockPlayerManager_Expecter) FindByPhone(phone interface{}) *MockPlayerManager_FindByPhone_Call {
	return &MockPlayerManager_FindByPhone_Call{Call: _e.mock.On("FindByPhone", phone)}
}

func (_c *MockPlayerManager_FindByPhone_Call) Run(run func(phone string)) *MockPlayerManager_FindByPhone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPlayerManager_FindByPhone_Call) Return(player *models.Player, err error) *MockPlayerManager_FindByPhone_Call {
	_c.Call.Return(player, err)
	return _c
}

func (_c *MockPlayerManager_FindByPhone_Call) RunAndReturn(run func(phone string) (*models.Player, error)) *MockPlayerManager_FindByPhone_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTokenManager creates a new instance of MockTokenManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTokenManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTokenManager {
	mock := &MockTokenManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTokenManager is an autogenerated mock type for the TokenManager type
type MockTokenManager struct {
	mock.Mock
}

type MockTokenManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTokenManager) EXPECT() *MockTokenManager_Expecter {
	return &MockTokenManager_Expecter{mock: &_m.Mock}
}

// BlockToken provides a mock function for the type MockTokenManager
func (_mock *MockTokenManager) BlockToken(tokenID uint64) error {
	ret := _mock.Called(tokenID)

	if len(ret) == 0 {
		panic("no return value specified for BlockToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(tokenID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTokenManager_BlockToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockToken'
type MockTokenManager_BlockToken_Call struct {
	*mock.Call
}

// BlockToken is a helper method to define mock.On call
//   - tokenID uint64
func (_e *MockTokenManager_Expecter) BlockToken(tokenID interface{}) *MockTokenManager_BlockToken_Call {
	return &MockTokenManager_BlockToken_Call{Call: _e.mock.On("BlockToken", tokenID)}
}

func (_c *MockTokenManager_BlockToken_Call) Run(run func(tokenID uint64)) *MockTokenManager_BlockToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenManager_BlockToken_Call) Return(err error) *MockTokenManager_BlockToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTokenManager_BlockToken_Call) RunAndReturn(run func(tokenID uint64) error) *MockTokenManager_BlockToken_Call {
	_c.Call.Return(run)
	return _c
}

// FindActualByPlayerID provides a mock function for the type MockTokenManager
func (_mock *MockTokenManager) FindActualByPlayerID(playerID uint64) (*models.Token, error) {
	ret := _mock.Called(playerID)

	if len(ret) == 0 {
		panic("no return value specified for FindActualByPlayerID")
	}

	var r0 *models.Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*models.Token, error)); ok {
		return returnFunc(playerID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *models.Token); ok {
		r0 = returnFunc(playerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(playerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenManager_FindActualByPlayerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindActualByPlayerID'
type MockTokenManager_FindActualByPlayerID_Call struct {
	*mock.Call
}

// FindActualByPlayerID is a helper method to define mock.On call
//   - playerID uint64
func (_e *MockTokenManager_Expecter) FindActualByPlayerID(playerID interface{}) *MockTokenManager_FindActualByPlayerID_Call {
	return &MockTokenManager_FindActualByPlayerID_Call{Call: _e.mock.On("FindActualByPlayerID", playerID)}
}

func (_c *MockTokenManager_FindActualByPlayerID_Call) Run(run func(playerID uint64)) *MockTokenManager_FindActualByPlayerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenManager_FindActualByPlayerID_Call) Return(token *models.Token, err error) *MockTokenManager_FindActualByPlayerID_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenManager_FindActualByPlayerID_Call) RunAndReturn(run func(playerID uint64) (*models.Token, error)) *MockTokenManager_FindActualByPlayerID_Call {
	_c.Call.Return(run)
	return _c
}

// FindActualByToken provides a mock function for the type MockTokenManager
func (_mock *MockTokenManager) FindActualByToken(token string) (*models.Token, error) {
	ret := _mock.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for FindActualByToken")
	}

	var r0 *models.Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*models.Token, error)); ok {
		return returnFunc(token)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *models.Token); ok {
		r0 = returnFunc(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenManager_FindActualByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindActualByToken'
type MockTokenManager_FindActualByToken_Call struct {
	*mock.Call
}

// FindActualByToken is a helper method to define mock.On call
//   - token string
func (_e *MockTokenManager_Expecter) FindActualByToken(token interface{}) *MockTokenManager_FindActualByToken_Call {
	return &MockTokenManager_FindActualByToken_Call{Call: _e.mock.On("FindActualByToken", token)}
}

func (_c *MockTokenManager_FindActualByToken_Call) Run(run func(token string)) *MockTokenManager_FindActualByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenManager_FindActualByToken_Call) Return(token1 *models.Token, err error) *MockTokenManager_FindActualByToken_Call {
	_c.Call.Return(token1, err)
	return _c
}

func (_c *MockTokenManager_FindActualByToken_Call) RunAndReturn(run func(token string) (*models.Token, error)) *MockTokenManager_FindActualByToken_Call {
	_c.Call.Return(run)
	return _c
}

// IssueToken provides a mock function for the type MockTokenManager
func (_mock *MockTokenManager) IssueToken(playerID uint64) (*models.Token, error) {
	ret := _mock.Called(playerID)

	if len(ret) == 0 {
		panic("no return value specified for IssueToken")
	}

	var r0 *models.Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*models.Token, error)); ok {
		return returnFunc(playerID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *models.Token); ok {
		r0 = returnFunc(playerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(playerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTokenManager_IssueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueToken'
type MockTokenManager_IssueToken_Call struct {
	*mock.Call
}

// IssueToken is a helper method to define mock.On call
//   - playerID uint64
func (_e *MockTokenManager_Expecter) IssueToken(playerID interface{}) *MockTokenManager_IssueToken_Call {
	return &MockTokenManager_IssueToken_Call{Call: _e.mock.On("IssueToken", playerID)}
}

func (_c *MockTokenManager_IssueToken_Call) Run(run func(playerID uint64)) *MockTokenManager_IssueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTokenManager_IssueToken_Call) Return(token *models.Token, err error) *MockTokenManager_IssueToken_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *MockTokenManager_IssueToken_Call) RunAndReturn(run func(playerID uint64) (*models.Token, error)) *MockTokenManager_IssueToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdatesHandleManager creates a new instance of MockUpdatesHandleManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdatesHandleManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdatesHandleManager {
	mock := &MockUpdatesHandleManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdatesHandleManager is an autogenerated mock type for the UpdatesHandleManager type
type MockUpdatesHandleManager struct {
	mock.Mock
}

type MockUpdatesHandleManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdatesHandleManager) EXPECT() *MockUpdatesHandleManager_Expecter {
	return &MockUpdatesHandleManager_Expecter{mock: &_m.Mock}
}

// HandleMsgWithContact provides a mock function for the type MockUpdatesHandleManager
func (_mock *MockUpdatesHandleManager) HandleMsgWithContact(upd models.Update) error {
	ret := _mock.Called(upd)

	if len(ret) == 0 {
		panic("no return value specified for HandleMsgWithContact")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.Update) error); ok {
		r0 = returnFunc(upd)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUpdatesHandleManager_HandleMsgWithContact_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleMsgWithContact'
type MockUpdatesHandleManager_HandleMsgWithContact_Call struct {
	*mock.Call
}

// HandleMsgWithContact is a helper method to define mock.On call
//   - upd models.Update
func (_e *MockUpdatesHandleManager_Expecter) HandleMsgWithContact(upd interface{}) *MockUpdatesHandleManager_HandleMsgWithContact_Call {
	return &MockUpdatesHandleManager_HandleMsgWithContact_Call{Call: _e.mock.On("HandleMsgWithContact", upd)}
}

func (_c *MockUpdatesHandleManager_HandleMsgWithContact_Call) Run(run func(upd models.Update)) *MockUpdatesHandleManager_HandleMsgWithContact_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.Update
		if args[0] != nil {
			arg0 = args[0].(models.Update)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUpdatesHandleManager_HandleMsgWithContact_Call) Return(err error) *MockUpdatesHandleManager_HandleMsgWithContact_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUpdatesHandleManager_HandleMsgWithContact_Call) RunAndReturn(run func(upd models.Update) error) *MockUpdatesHandleManager_HandleMsgWithContact_Call {
	_c.Call.Return(run)
	return _c
}

// HandleStartMsg provides a mock function for the type MockUpdatesHandleManager
func (_mock *MockUpdatesHandleManager) HandleStartMsg(upd models.Update) error {
	ret := _mock.Called(upd)

	if len(ret) == 0 {
		panic("no return value specified for HandleStartMsg")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.Update) error); ok {
		r0 = returnFunc(upd)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUpdatesHandleManager_HandleStartMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleStartMsg'
type MockUpdatesHandleManager_HandleStartMsg_Call struct {
	*mock.Call
}

// HandleStartMsg is a helper method to define mock.On call
//   - upd models.Update
func (_e *MockUpdatesHandleManager_Expecter) HandleStartMsg(upd interface{}) *MockUpdatesHandleManager_HandleStartMsg_Call {
	return &MockUpdatesHandleManager_HandleStartMsg_Call{Call: _e.mock.On("HandleStartMsg", upd)}
}

func (_c *MockUpdatesHandleManager_HandleStartMsg_Call) Run(run func(upd models.Update)) *MockUpdatesHandleManager_HandleStartMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.Update
		if args[0] != nil {
			arg0 = args[0].(models.Update)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUpdatesHandleManager_HandleStartMsg_Call) Return(err error) *MockUpdatesHandleManager_HandleStartMsg_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUpdatesHandleManager_HandleStartMsg_Call) RunAndReturn(run func(upd models.Update) error) *MockUpdatesHandleManager_HandleStartMsg_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdatesManager creates a new instance of MockUpdatesManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdatesManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdatesManager {
	mock := &MockUpdatesManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdatesManager is an autogenerated mock type for the UpdatesManager type
type MockUpdatesManager struct {
	mock.Mock
}

type MockUpdatesManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdatesManager) EXPECT() *MockUpdatesManager_Expecter {
	return &MockUpdatesManager_Expecter{mock: &_m.Mock}
}

// Get provides a mock function for the type MockUpdatesManager
func (_mock *MockUpdatesManager) Get(offset int) ([]models.Update, error) {
	ret := _mock.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []models.Update
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int) ([]models.Update, error)); ok {
		return returnFunc(offset)
	}
	if returnFunc, ok := ret.Get(0).(func(int) []models.Update); ok {
		r0 = returnFunc(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Update)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int) error); ok {
		r1 = returnFunc(offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdatesManager_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockUpdatesManager_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - offset int
func (_e *MockUpdatesManager_Expecter) Get(offset interface{}) *MockUpdatesManager_Get_Call {
	return &MockUpdatesManager_Get_Call{Call: _e.mock.On("Get", offset)}
}

func (_c *MockUpdatesManager_Get_Call) Run(run func(offset int)) *MockUpdatesManager_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUpdatesManager_Get_Call) Return(updates []models.Update, err error) *MockUpdatesManager_Get_Call {
	_c.Call.Return(updates, err)
	return _c
}

func (_c *MockUpdatesManager_Get_Call) RunAndReturn(run func(offset int) ([]models.Update, error)) *MockUpdatesManager_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Process provides a mock function for the type MockUpdatesManager
func (_mock *MockUpdatesManager) Process(updates []models.Update) {
	_mock.Called(updates)
	return
}

// MockUpdatesManager_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type MockUpdatesManager_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - updates []models.Update
func (_e *MockUpdatesManager_Expecter) Process(updates interface{}) *MockUpdatesManager_Process_Call {
	return &MockUpdatesManager_Process_Call{Call: _e.mock.On("Process", updates)}
}

func (_c *MockUpdatesManager_Process_Call) Run(run func(updates []models.Update)) *MockUpdatesManager_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []models.Update
		if args[0] != nil {
			arg0 = args[0].([]models.Update)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUpdatesManager_Process_Call) Return() *MockUpdatesManager_Process_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockUpdatesManager_Process_Call) RunAndReturn(run func(updates []models.Update)) *MockUpdatesManager_Process_Call {
	_c.Run(run)
	return _c
}
