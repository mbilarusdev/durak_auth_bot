package repository_test

import (
	"fmt"
	"testing"

	"context"
	"time"

	"github.com/docker/go-connections/nat"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/mbilarusdev/durak_auth_bot/internal/adapter"
	"github.com/mbilarusdev/durak_auth_bot/internal/models"
	"github.com/mbilarusdev/durak_auth_bot/internal/repository"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestTokenRepositoryDocker(t *testing.T) {
	ctx := context.Background()
	req := testcontainers.ContainerRequest{
		Image:        "postgres:latest",
		ExposedPorts: []string{"5432/tcp"},
		WaitingFor:   wait.ForListeningPort(nat.Port("5432/tcp")),
		Env: map[string]string{
			"POSTGRES_USER":     "test_user",
			"POSTGRES_PASSWORD": "test_password",
			"POSTGRES_DB":       "test_db",
		},
	}
	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	if err != nil {
		t.Fatalf("Couldn't start container: %s", err)
	}
	defer container.Terminate(ctx)

	ip, err := container.Host(ctx)
	if err != nil {
		t.Fatalf("Couldn't get host ip: %s", err)
	}

	port, err := container.MappedPort(ctx, "5432")
	if err != nil {
		t.Fatalf("Couldn't get mapped port: %s", err)
	}

	dsn := fmt.Sprintf(
		"postgres://test_user:test_password@%s:%s/test_db?sslmode=disable&pool_max_conns=1&pool_max_conn_lifetime=1h30m",
		ip,
		port.Port(),
	)

	time.Sleep(time.Second * 5)

	conf, err := pgxpool.ParseConfig(dsn)

	if err != nil {
		t.Fatalf("Error when parse config: %s", err)
	}

	pool, err := pgxpool.NewWithConfig(ctx, conf)
	if err != nil {
		t.Fatalf("Failed to create pgx pool: %s", err)
	}
	defer pool.Close()

	conn, err := pool.Acquire(ctx)
	if err != nil {
		t.Fatalf("Failed to get pgx conn from pool: %s", err)
	}

	_, err = conn.Exec(ctx, `
        CREATE TABLE IF NOT EXISTS players (
		id          BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
		username    VARCHAR(255) NOT NULL,
		phone_number VARCHAR(255) NOT NULL,
		chat_id     INTEGER NOT NULL,
		created_at  BIGINT NOT NULL
	);
    `)

	_, err = conn.Exec(ctx, `
        CREATE TABLE IF NOT EXISTS tokens (
		id          BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
		player_id    BIGINT NOT NULL,
		jwt 	VARCHAR(255) NOT NULL,
		status     VARCHAR(255) NOT NULL,
		FOREIGN KEY (player_id) REFERENCES players(id)
	);
    `)

	if err != nil {
		t.Fatalf("Couldn't create tokens table: %s", err)
	}
	conn.Release()

	t.Run("Token Inserted then Updated and Finded with success", func(t *testing.T) {
		playerRepo := repository.NewPlayerRepository(adapter.NewAdapterPool(pool))

		player := &models.Player{
			Username:    "Nikola",
			PhoneNumber: "+79150719486",
			ChatID:      10,
			CreatedAt:   time.Now().UTC().Unix(),
		}
		_, err := playerRepo.Insert(player)
		if err != nil {
			t.Fatalf("Create player failed: %s", err)
		}

		repository := repository.NewTokenRepository(adapter.NewAdapterPool(pool))

		token := &models.Token{
			PlayerID: 1,
			Jwt:      "TOKEN",
			Status:   models.TokenAvailable,
		}
		tokenID, err := repository.Insert(token)
		if err != nil {
			t.Fatalf("Create token failed: %s", err)
		}

		err = repository.UpdateStatus(tokenID, models.TokenBlocked)
		if err != nil {
			t.Fatalf("Update token failed: %s", err)
		}

		foundTokenById, err := repository.FindOne(&models.TokenFindOptions{ID: tokenID})
		if err != nil {
			t.Fatalf("Find token by id failed: %s", err)
		}

		if foundTokenById.Status != models.TokenBlocked {
			t.Fatalf("Test failed: status not updated")
		}

		foundTokenById.ID = 0
		foundTokenById.Status = models.TokenAvailable
		if *foundTokenById != *token {
			t.Fatalf("Test failed finded token not equals to inserted token!")
		}

		conn, err := pool.Acquire(ctx)
		if err != nil {
			t.Fatalf("Failed to get pgx conn from pool: %s", err)
		}
		defer conn.Release()

		_, err = conn.Exec(ctx, "DELETE FROM tokens WHERE id = 1")

		if err != nil {
			t.Logf("Cleanup failed: %s", err)
		}
	})
}
